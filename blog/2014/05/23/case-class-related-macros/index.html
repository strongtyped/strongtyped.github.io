
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Macros: Case Class Related Macros - Strong[Typed]</title>
  <meta name="author" content="StrongTyped.io">

  
  <meta name="description" content="Strong[Typed] blog Macros: Case Class Related Macros written May 23, 2014 in Posted by Luc Duponcheel home This is a first blog post about Writing &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.strongtyped.io/blog/2014/05/23/case-class-related-macros">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Strong[Typed]" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-50926236-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Exo:400,500,600,500italic,600italic" rel="stylesheet" type="text/css">

</head>

<!-- _layouts/default.html -->
  <body>

    <!-- _layouts/post.html -->

<div class="navbar">
  <div class="navbar-fixed-top">
      <div class="container">
      <ul class="nav navbar-left">
        <li>
          <h2 class="strongtyped"><a href="/"><span class="strong">Strong<span><span class="typed">[Typed]</span></a></h2>
        </li>
      </ul>
      <ul class="nav secondary-nav navbar-nav navbar-right">
  <li><a id="blog-nav" href="/blog">blog</a></li>
</ul>      
    </div>
  </div>
</div>


<article role="article" class="full-single-article">
  <div class="container">
    <div class="row">
      <div class="col-md-10 col-md-offset-1">
        <h1>Macros: Case Class Related Macros</h1>
        <!-- post/metadata.html --> 
<span class="meta">
  written 








  



<time datetime="2014-05-23T09:00:00+02:00" pubdate data-updated="true">May 23, 2014</time>  
in 


<br/>
  

<span class="byline author vcard">Posted by <span class="fn">Luc Duponcheel</span></span>

</span>
        <p><a href="/">home</a></p>

<p>This is a first blog post about <em>Writing Macros in Scala</em>.
This blog post covers two interesting pairs of macros dealing with <em>case classes</em>.
The macros of the first pair translate <em>case classes to tuples</em>, and <em>tuples to case classes</em>.
The macros of the second pair translate <em>case classes to maps</em>, and <em>maps to case classes</em>.</p>

<p><strong>Remark:</strong>
The macros presented in this blog can be found elsewhere on the internet.
We tried to reuse as much code as possible for both pairs of macros using a <code>Common</code> singleton object. Moreover, we end by adding a bit of extra code of our own as well.</p>

<!-- more -->


<h2>Case classes and Tuples</h2>

<p>The tranformations
from case classes <code>Z</code> to tuples <code>T</code>
and
from tuples <code>T</code> to case classes <code>Z</code>
can be formalized as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">trait</span> <span class="nc">ToTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">toTuple</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">trait</span> <span class="nc">FromTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">fromTuple</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>The <code>toTuple</code> and <code>fromTuple</code> functions</h2>

<p>It turns out that it is convenient to define <em>implicit macros</em> of type <code>ToTuple[Z, T]</code> and <code>FromTuple[Z, T]</code>.
Assuming the existence of such macros, it is also convenient to define functions
<code>toTuple</code> and <code>fromTuple</code> that  <code>implicitly</code> make use of them</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">toTuple</span><span class="o">[</span><span class="kt">Z:</span> <span class="o">({</span> <span class="k">type</span> <span class="kt">ToTuple_</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">ToTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span> <span class="o">})</span><span class="k">#</span><span class="kt">ToTuple_</span>, <span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">ToTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]].</span><span class="n">toTuple</span><span class="o">(</span><span class="n">z</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">fromTuple</span><span class="o">[</span><span class="kt">Z:</span> <span class="o">({</span> <span class="k">type</span> <span class="kt">FromTuple_</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">FromTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span> <span class="o">})</span><span class="k">#</span><span class="kt">FromTuple_</span>, <span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">FromTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]].</span><span class="n">fromTuple</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The definitions above make use of type constructors <code>ToTuple_</code> resp. <code>FromTuple_</code>,
having <em>one type parameter</em>, that are obtained by <em>partially binding</em> the
the type <code>T</code> to the second type parameter of the type constructors <code>ToTuple</code> resp. <code>FromTuple</code>,
having <em>two type parameters</em>.</p>

<h2>An example case class</h2>

<p>Consider the case class</p>

<ul>
<li><code>case class Person(name: String, age: Int)</code></li>
</ul>


<p>The tuple class corresponding to this case class is</p>

<ul>
<li><code>(String, Int)</code></li>
</ul>


<p>Here is the code that a macro should generate to convert a <code>Person</code> instance
to a <code>(String, Int)</code> instance</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">new</span> <span class="nc">ToTuple</span><span class="o">[</span><span class="kt">Person</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toTuple</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">z</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">z</span><span class="o">.</span><span class="n">age</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here is the code that a macro should generate to convert a <code>(String, Int)</code> instance
to a <code>Person</code> instance</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">new</span> <span class="nc">FromTuple</span><span class="o">[</span><span class="kt">Person</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">fromTuple</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">t</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, what is the information that we require at compile time
for being able to generate this code?</p>

<ul>
<li>we require the string <code>"Person"</code></li>
<li>we require the strings <code>"String"</code> and <code>"Int"</code></li>
<li>we require the strings <code>"name"</code> and <code>"age"</code></li>
<li>we require the number <code>2</code> to generate the strings <code>"1"</code> and <code>"2"</code></li>
</ul>


<p>The last requirement is not really needed if we replace the first three
requirements above by</p>

<ul>
<li>we require the string <code>"Person"</code></li>
<li>we require the list of strings containing <code>"String"</code> and <code>"Int"</code></li>
<li>we require the list of strings containing <code>"name"</code> and <code>"age"</code></li>
</ul>


<p>because the lists above have size <code>2</code>.</p>

<p>So how can we obtain all those required strings?</p>

<h2>The <code>getFieldNamesAndTypes</code> method</h2>

<p>The following code is all we need to obtain the required strings</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">trait</span> <span class="nc">Common</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">getFieldNamesAndTypes</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)(</span><span class="n">tpe</span><span class="k">:</span> <span class="kt">c.universe.Type</span><span class="o">)</span><span class="k">:</span>
</span><span class='line'>      <span class="kt">Iterable</span><span class="o">[(</span><span class="kt">c.universe.Name</span>, <span class="kt">c.universe.Type</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">import</span> <span class="nn">c.universe._</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">object</span> <span class="nc">CaseField</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">trmSym</span><span class="k">:</span> <span class="kt">TermSymbol</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">Name</span>, <span class="kt">Type</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">trmSym</span><span class="o">.</span><span class="n">isVal</span> <span class="o">&amp;&amp;</span> <span class="n">trmSym</span><span class="o">.</span><span class="n">isCaseAccessor</span><span class="o">)</span>
</span><span class='line'>             <span class="nc">Some</span><span class="o">((</span><span class="n">newTermName</span><span class="o">(</span><span class="n">trmSym</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">trim</span><span class="o">),</span> <span class="n">trmSym</span><span class="o">.</span><span class="n">typeSignature</span><span class="o">))</span>
</span><span class='line'>          <span class="k">else</span>
</span><span class='line'>            <span class="nc">None</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">tpe</span><span class="o">.</span><span class="n">declarations</span><span class="o">.</span><span class="n">collect</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nc">CaseField</span><span class="o">(</span><span class="n">nme</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>          <span class="o">(</span><span class="n">nme</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The code above has a <code>Context</code> parameter <code>c</code>, using which we can obtain all
the types we need using <code>import c.universe._</code>.</p>

<p>The only information available to start generating code from is <code>tpe</code>, having type <code>Type</code>.
The <code>object CaseField</code>&rsquo;s <code>unapply</code> method can be used to<em> extract</em> the
information that we need from the <em>declarations</em> of <code>tpe</code>,
using a <em>collection</em> that uses an appropriate <code>CaseField</code> pattern matching partial function.</p>

<p>Maybe, by looking at the code, you may wonder why it uses
the somewhat complex expression <code>newTermName(trmSym.name.toString.trim)</code> instead
of the much simpler expression <code>trmSym.name</code>.
Writing macros is still somewhat of a <em>black art</em>.
It turns out that using <code>trmSym.name</code> would result in strings
<code>"name "</code> and <code>"age "</code>, with an extra blank at the end,
and we can get rid of that extra blank using
the more complex expression <code>newTermName(trmSym.name.toString.trim)</code>.</p>

<h2>The <code>toTupleMacro</code> macro</h2>

<p>Using the <code>getFieldNamesAndTypes</code> method we can now define the
implicit <code>toTupleMacro</code> as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">object</span> <span class="nc">ToTuple</span> <span class="k">extends</span> <span class="nc">Common</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">def</span> <span class="n">toTupleMacro</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">ToTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">macro</span> <span class="n">toTupleMacroImpl</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">toTupleMacroImpl</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">c.WeakTypeTag</span>, <span class="kt">T</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)</span><span class="k">:</span> <span class="kt">c.Expr</span><span class="o">[</span><span class="kt">ToTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">import</span> <span class="nn">c.universe._</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">weakTypeOf</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="o">(</span><span class="n">nmes</span><span class="o">,</span> <span class="n">tpes</span><span class="o">)</span> <span class="k">=</span> <span class="n">getFieldNamesAndTypes</span><span class="o">(</span><span class="n">c</span><span class="o">)(</span><span class="n">tpe</span><span class="o">).</span><span class="n">unzip</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">fldSels</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Select</span><span class="o">]</span> <span class="k">=</span> <span class="n">nmes</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">nme</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">         z.$nme</span>
</span><span class='line'><span class="s">        &quot;&quot;&quot;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">toTuple</span><span class="k">:</span> <span class="kt">Tree</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">         new ToTuple[$tpe, (..$tpes)] {</span>
</span><span class='line'><span class="s">           def toTuple(z: $tpe) = (..$fldSels)</span>
</span><span class='line'><span class="s">         }</span>
</span><span class='line'><span class="s">        &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">c</span><span class="o">.</span><span class="nc">Expr</span><span class="o">[</span><span class="kt">ToTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]](</span><span class="n">toTuple</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The macro, in this case one of type <code>ToTuple[Z, T]</code>, is <em>declared</em> using a <code>macro</code> keyword.
The macro is <em>definied</em> using a method of type <code>c.Expr</code>,
in this case of type <code>c.Expr[ToTuple[Z, T]]</code>.
The method has an extra parameter of type <code>Context</code>.
The macro makes use of <em>quasi-quotes</em>, the preferred way to generate code. We use <code>unzip</code>
to turn a list of tuples into a tuple of lists. The <code>tpes</code> can be used as such in the
quasi-quote expression that defines <code>toTuple</code>. The <code>nmes</code> can be used to define <em>field selections</em>
<code>fldSels</code> that can be used in the quasi-quote expression that defines <code>toTuple</code>.
The variable <code>toTuple</code> has type <code>Tree</code> and the macro needs a <code>c.Expr[ToTuple[Z, T]]</code>
type. Therefore we wrap <code>toTuple</code> into an expression of type <code>c.Expr[ToTuple[Z, T]]</code>.</p>

<h2>The <code>fromTupleMacro</code> macro</h2>

<p>Using the <code>getFieldNamesAndTypes</code> method we can now define the
implicit <code>fromTupleMacro</code> as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">object</span> <span class="nc">FromTuple</span> <span class="k">extends</span> <span class="nc">Common</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">def</span> <span class="n">fromTupleMacro</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">FromTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">macro</span> <span class="n">fromTupleMacroImpl</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">fromTupleMacroImpl</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">c.WeakTypeTag</span>, <span class="kt">T</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)</span><span class="k">:</span> <span class="kt">c.Expr</span><span class="o">[</span><span class="kt">FromTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">import</span> <span class="nn">c.universe._</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">weakTypeOf</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="o">(</span><span class="n">nmes</span><span class="o">,</span> <span class="n">tpes</span><span class="o">)</span> <span class="k">=</span> <span class="n">getFieldNamesAndTypes</span><span class="o">(</span><span class="n">c</span><span class="o">)(</span><span class="n">tpe</span><span class="o">).</span><span class="n">unzip</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="n">prj</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">TermName</span> <span class="o">=</span> <span class="n">newTermName</span><span class="o">(</span><span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">prjs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Select</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">nmes</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">         t.${prj(i)}</span>
</span><span class='line'><span class="s">        &quot;&quot;&quot;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">tpeSym</span><span class="k">:</span> <span class="kt">Symbol</span> <span class="o">=</span> <span class="n">tpe</span><span class="o">.</span><span class="n">typeSymbol</span><span class="o">.</span><span class="n">companionSymbol</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">fromTuple</span><span class="k">:</span> <span class="kt">Tree</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">         new FromTuple[$tpe, (..$tpes)] {</span>
</span><span class='line'><span class="s">           def fromTuple(t: (..$tpes)) = ${tpeSym}(..$prjs)</span>
</span><span class='line'><span class="s">         }</span>
</span><span class='line'><span class="s">        &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">c</span><span class="o">.</span><span class="nc">Expr</span><span class="o">[</span><span class="kt">FromTuple</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">T</span><span class="o">]](</span><span class="n">fromTuple</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The macro, in this case one of type <code>FromTuple[Z, T]</code>,  is <em>declared</em> using a <code>macro</code> keyword.
The macro is <em>definied</em> using a method of type <code>c.Expr</code>,
in this case of type <code>c.Expr[FromTuple[Z, T]]</code>.
The method has an extra parameter of type <code>Context</code>.
The macro makes use of <em>quasi-quotes</em>, the preferred way to generate code. We use <code>unzip</code>
to turn a list of tuples into a tuple of lists. The <code>tpes</code> can be used as such in the
quasi-quote expression that defines <code>fromTuple</code>. The <code>nmes</code> can be used to define <em>projections</em>
<code>prjs</code> that can be used in the quasi-quote expression that defines <code>fromTuple</code>.
We also need <code>tpeSym</code> the <em>type symbol</em> of the <em>companion object</em> of the case class.
The variable <code>fromTuple</code> has type <code>Tree</code> and the macro needs a <code>c.Expr[FromTuple[Z, T]]</code>
type. Therefore we wrap <code>fromTuple</code> into an expression of type <code>c.Expr[FromTuple[Z, T]]</code>.</p>

<p>Here is an example</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">MacroApp</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">person</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="mi">40</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">toTuple</span><span class="o">(</span><span class="n">person</span><span class="o">))</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">fromTuple</span><span class="o">[</span><span class="kt">Person</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]((</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="mi">40</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>printing</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="nc">John</span><span class="o">,</span><span class="mi">40</span><span class="o">)</span>
</span><span class='line'><span class="nc">Person</span><span class="o">(</span><span class="nc">John</span><span class="o">,</span><span class="mi">40</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Case classes and Maps</h2>

<p>The tranformations
from case classes <code>Z</code> to maps <code>Map[String, Any]</code>
and
from maps <code>Map[String, Any]</code> to case classes <code>Z</code>
can be formalized as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">type</span> <span class="kt">M</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">trait</span> <span class="nc">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">store</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">trait</span> <span class="nc">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">load</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>The <code>store</code> and <code>load</code> functions</h2>

<p>It turns out that it is convenient to define <em>implicit macros</em> of type <code>Store[Z]</code> and <code>Load[Z]</code>.
Assuming the existence of such macros, it is also convenient to define functions
<code>store</code> and <code>load</code> that <code>implicitly</code> make use of them</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">store</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">Store</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]].</span><span class="n">store</span><span class="o">(</span><span class="n">z</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">load</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">Load</span><span class="o">](</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]].</span><span class="n">load</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>An example case class</h2>

<p>Consider the case class</p>

<ul>
<li><code>case class Person(name: String, age: Int)</code></li>
</ul>


<p>Here is the code that a macro should generate to convert a <code>Person</code> instance
to an <code>M</code> instance</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">new</span> <span class="nc">Store</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">store</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=</span>
</span><span class='line'>      <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;name&quot;</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="s">&quot;age&quot;</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">.</span><span class="n">age</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here is the code that a macro should generate to convert an <code>M</code> instance
to a <code>Person</code> instance</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">new</span> <span class="nc">Load</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">load</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">)</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span>
</span><span class='line'>      <span class="nc">Person</span><span class="o">(</span><span class="n">m</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">m</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The information that we require at compile time
for being able to generate this code is exactly the same
as when converting from and to tuples, so we can reuse
the <code>getFieldNamesAndTypes</code> method.</p>

<h2>The <code>storeMacro</code> macro</h2>

<p>Using the <code>getFieldNamesAndTypes</code> method we can now define the
implicit <code>storeMacro</code> as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">object</span> <span class="nc">Store</span> <span class="k">extends</span> <span class="nc">Common</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">def</span> <span class="n">storeMacro</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="k">=</span> <span class="n">macro</span> <span class="n">storeMacroImpl</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">storeMacroImpl</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">c.WeakTypeTag</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)</span><span class="k">:</span> <span class="kt">c.Expr</span><span class="o">[</span><span class="kt">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">import</span> <span class="nn">c.universe._</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">weakTypeOf</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">mpgs</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Apply</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">getFieldNamesAndTypes</span><span class="o">(</span><span class="n">c</span><span class="o">)(</span><span class="n">tpe</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="o">(</span><span class="n">nme</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>            <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">            ${nme.decoded} -&gt; z.${nme}</span>
</span><span class='line'><span class="s">            &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">store</span><span class="k">:</span> <span class="kt">Tree</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">         new Store[$tpe] {</span>
</span><span class='line'><span class="s">           def store(z: $tpe): M =</span>
</span><span class='line'><span class="s">             Map(..$mpgs)</span>
</span><span class='line'><span class="s">         }</span>
</span><span class='line'><span class="s">         &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">c</span><span class="o">.</span><span class="nc">Expr</span><span class="o">[</span><span class="kt">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]](</span><span class="n">store</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The macro, in this case one of type <code>Store[Z]</code>, is <em>declared</em> using a <code>macro</code> keyword.
The macro is <em>definied</em> using a method of type <code>c.Expr</code>,
in this case of type <code>c.Expr[Store[Z]]</code>.
The method has an extra parameter of type <code>Context</code>.
The macro makes use of <em>quasi-quotes</em>, the preferred way to generate code.
<code>getFieldNamesAndTypes(c)(tpe)</code> can be used to define <em>mappings</em>
<code>mpgs</code> that can be used in the quasi-quote expression that defines <code>store</code>.
The mappings use the field names in two ways: with and without double-quotes.
The variable <code>store</code> has type <code>Tree</code> and the macro needs a <code>c.Expr[Store[Z]]</code>
type. Therefore we wrap <code>store</code> into an expression of type <code>c.Expr[Store[Z]]</code>.</p>

<h2>The <code>loadMacro</code> macro</h2>

<p>Using the <code>getFieldNamesAndTypes</code> method we can now define the
implicit <code>loadMacro</code> as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">object</span> <span class="nc">Load</span> <span class="k">extends</span> <span class="nc">Common</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">def</span> <span class="n">loadMacro</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span><span class="k">:</span> <span class="kt">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="k">=</span> <span class="n">macro</span> <span class="n">loadMacroImpl</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">loadMacroImpl</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">c.WeakTypeTag</span><span class="o">](</span>
</span><span class='line'>      <span class="n">c</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)</span><span class="k">:</span> <span class="kt">c.Expr</span><span class="o">[</span><span class="kt">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">import</span> <span class="nn">c.universe._</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">weakTypeOf</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">args</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">getFieldNamesAndTypes</span><span class="o">(</span><span class="n">c</span><span class="o">)(</span><span class="n">tpe</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="o">(</span><span class="n">nme</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>            <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">            m(${nme.decoded}).asInstanceOf[${tpe}]</span>
</span><span class='line'><span class="s">            &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">tpeSym</span><span class="k">:</span> <span class="kt">Symbol</span> <span class="o">=</span> <span class="n">tpe</span><span class="o">.</span><span class="n">typeSymbol</span><span class="o">.</span><span class="n">companionSymbol</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">val</span> <span class="n">load</span><span class="k">:</span> <span class="kt">Tree</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">q</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="s">         new Load[$tpe] {</span>
</span><span class='line'><span class="s">           def load(m: M): $tpe =</span>
</span><span class='line'><span class="s">             ${tpeSym}(..$args)</span>
</span><span class='line'><span class="s">         }</span>
</span><span class='line'><span class="s">         &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">c</span><span class="o">.</span><span class="nc">Expr</span><span class="o">[</span><span class="kt">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]](</span><span class="n">load</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The macro, in this case one of type <code>Load[Z]</code>, is <em>declared</em> using a <code>macro</code> keyword.
The macro is <em>definied</em> using a method of type <code>c.Expr</code>,
in this case of type <code>c.Expr[Load[Z]]</code>.
The method has an extra parameter of type <code>Context</code>.
The macro makes use of <em>quasi-quotes</em>, the preferred way to generate code.
<code>getFieldNamesAndTypes(c)(tpe)</code> can be used to define <em>case class constructor arguments</em>
<code>args</code> that can be used in the quasi-quote expression that defines <code>load</code>.
We also need <code>tpeSym</code> the <em>type symbol</em> of the <em>companion object</em> of the case class.
The variable <code>load</code> has type <code>Tree</code> and the macro needs a <code>c.Expr[Load[Z]]</code>
type. Therefore we wrap <code>load</code> into an expression of type <code>c.Expr[Load[Z]]</code>.</p>

<p>Here is an example</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">MacroApp</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">person</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="mi">40</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">store</span><span class="o">(</span><span class="n">person</span><span class="o">))</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">load</span><span class="o">[</span><span class="kt">Person</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)](</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;name&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span> <span class="o">-&gt;</span> <span class="mi">40</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>printing</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">John</span><span class="o">,</span> <span class="n">age</span> <span class="o">-&gt;</span> <span class="mi">40</span><span class="o">)</span>
</span><span class='line'><span class="nc">Person</span><span class="o">(</span><span class="nc">John</span><span class="o">,</span><span class="mi">40</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Loading and Storing other types</h2>

<p>Now that we know how to load and store case class instances, what about other classes?
If there exist <em>bidirectional mappings</em> from a class to a case class, then we can use
those mappings to load and store instances of that class.
The way those bidirectional mappings can be used is formalized as follows</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">Y</span><span class="o">](</span><span class="n">z2y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="o">)</span><span class="k">:</span> <span class="kt">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Load</span><span class="o">[</span><span class="kt">Y</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">lz</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Load</span><span class="o">[</span><span class="kt">Y</span><span class="o">]()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">load</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">)</span> <span class="k">=</span> <span class="n">z2y</span><span class="o">(</span><span class="n">lz</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">m</span><span class="o">))</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">tfil</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">Y</span><span class="o">](</span><span class="n">z2y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="o">)</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">Y</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">sy</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">store</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)</span> <span class="k">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">store</span><span class="o">(</span><span class="n">z2y</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">lift2load</span><span class="o">[</span><span class="kt">Z:</span> <span class="kt">Load</span>, <span class="kt">Y</span><span class="o">](</span><span class="n">z2y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="o">)</span><span class="k">:</span> <span class="kt">Load</span><span class="o">[</span><span class="kt">Y</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">lift</span><span class="o">(</span><span class="n">z2y</span><span class="o">)(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Load</span><span class="o">[</span><span class="kt">Z</span><span class="o">]])</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">tfil2store</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">Y:</span> <span class="kt">Store</span><span class="o">](</span><span class="n">z2y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="o">)</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">tfil</span><span class="o">(</span><span class="n">z2y</span><span class="o">)(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Store</span><span class="o">[</span><span class="kt">Y</span><span class="o">]])</span>
</span></code></pre></td></tr></table></div></figure>


<p>We have called the first function <code>lift</code> and the second one <code>tfil</code> to emphasize that
<code>lift</code> is <em>covariant</em> (the arrow direction is preserved) and
<code>tfil</code> <em>contravariant</em> (the arrow direction has changed).</p>

<p>Here is a first example</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">class</span> <span class="nc">Customer</span><span class="o">(</span><span class="k">val</span> <span class="n">named</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">aged</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">person2customer</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">customer2person</span><span class="o">(</span><span class="n">customer</span><span class="k">:</span> <span class="kt">Customer</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="n">named</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">aged</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">lift2load</span><span class="o">(</span><span class="n">person2customer</span><span class="o">).</span><span class="n">load</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;name&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span> <span class="o">-&gt;</span> <span class="mi">40</span><span class="o">)))</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">tfil2store</span><span class="o">(</span><span class="n">customer2person</span><span class="o">).</span><span class="n">store</span><span class="o">(</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="mi">40</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>printing</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Customer</span><span class="o">(</span><span class="nc">John</span><span class="o">,</span><span class="mi">40</span><span class="o">)</span>
</span><span class='line'><span class="nc">Map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">John</span><span class="o">,</span> <span class="n">age</span> <span class="o">-&gt;</span> <span class="mi">40</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here is a second example,
making use of the bidirectional mappings from case classes to tuples</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">lift2load</span><span class="o">(</span><span class="n">toTuple</span><span class="o">[</span><span class="kt">Person</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]).</span><span class="n">load</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;name&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span> <span class="o">-&gt;</span> <span class="mi">40</span><span class="o">)))</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">tfil2store</span><span class="o">(</span><span class="n">fromTuple</span><span class="o">[</span><span class="kt">Person</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]).</span><span class="n">store</span><span class="o">((</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="mi">40</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>printing</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="nc">John</span><span class="o">,</span><span class="mi">40</span><span class="o">)</span>
</span><span class='line'><span class="nc">Map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">John</span><span class="o">,</span> <span class="n">age</span> <span class="o">-&gt;</span> <span class="mi">40</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>




      </div>
      <div class="col-md-10 col-md-offset-1">
        
        <section id="comment">
            <h1 class="title">Comments</h1>
            <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        </section>
        
      </div>
    </div>
  </div>
</article>

<hr class="divider-short"/>



<div class="archive-link">
  <div class="container">
    <div class="row">
      <div class="col-md-10 col-md-offset-1">
        
          <a class="pull-left" href="/blog/2014/05/20/reactive-programming-schedulers-workers/" title="Previous Post: Reactive Programming: Schedulers and Workers">&laquo; Previous: Reactive Programming: Schedulers and Workers</a>
        

        
      </div>
    </div>
  </div>
</div>

    
    <footer role="contentinfo"><!-- file: _includes/footer.html -->
<footer id="footer" class="her-row">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
  
</div>

<div class="col-md-2">

</div>

<!-- file: _includes/end_footer.html -->
<div class="pull-right">
  
</div>


    </div>
  </div>
</footer>
</footer>
    

<script type="text/javascript">
      var disqus_shortname = 'strongtyped';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://www.strongtyped.io/blog/2014/05/23/case-class-related-macros/';
        var disqus_url = 'http://www.strongtyped.io/blog/2014/05/23/case-class-related-macros/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




 
  </body>
</html>
